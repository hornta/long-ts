{"version":3,"file":"long.modern.js","sources":["../src/long.ts"],"sourcesContent":["const INT_CACHE: Record<number, Long> = {};\nconst UINT_CACHE: Record<number, Long> = {};\n\nexport class Long {\n\tstatic readonly ZERO = Long.fromInt(0);\n\n\tstatic readonly UZERO = Long.fromInt(0, true);\n\n\tstatic readonly ONE = Long.fromInt(1);\n\n\tstatic readonly UONE = Long.fromInt(1, true);\n\n\tstatic readonly NEG_ONE = Long.fromInt(-1);\n\n\tstatic readonly MAX_VALUE = Long.fromBits(\n\t\t0xffffffff | 0,\n\t\t0x7fffffff | 0,\n\t\tfalse\n\t);\n\n\tstatic readonly MAX_UNSIGNED_VALUE = Long.fromBits(\n\t\t0xffffffff | 0,\n\t\t0xffffffff | 0,\n\t\ttrue\n\t);\n\n\tstatic readonly MIN_VALUE = Long.fromBits(0, 0x80000000 | 0, false);\n\n\tlow: number;\n\n\thigh: number;\n\n\tunsigned: boolean;\n\n\tconstructor(low: number, high: number, unsigned = false) {\n\t\tthis.low = low | 0;\n\t\tthis.high = high | 0;\n\t\tthis.unsigned = unsigned;\n\t}\n\n\t// Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n\ttoInt() {\n\t\treturn this.unsigned ? this.low >>> 0 : this.low;\n\t}\n\n\t// Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n\ttoNumber() {\n\t\tif (this.unsigned) {\n\t\t\treturn (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n\t\t}\n\t\treturn this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n\t}\n\n\t// Converts the Long to a string written in the specified radix.\n\ttoString(radix = 10): string {\n\t\tif (radix < 2 || 36 < radix) {\n\t\t\tthrow RangeError(\"radix\");\n\t\t}\n\t\tif (this.isZero()) {\n\t\t\treturn \"0\";\n\t\t}\n\t\tif (this.isNegative()) {\n\t\t\t// Unsigned Longs are never negative\n\t\t\tif (this.equals(Long.MIN_VALUE)) {\n\t\t\t\t// We need to change the Long value before it can be negated, so we remove\n\t\t\t\t// the bottom-most digit in this base and then recurse to do the rest.\n\t\t\t\tconst radixLong = Long.fromNumber(radix);\n\t\t\t\tconst div = this.divide(radixLong);\n\t\t\t\tconst rem1 = div.multiply(radixLong).subtract(this);\n\t\t\t\treturn div.toString(radix) + rem1.toInt().toString(radix);\n\t\t\t} else {\n\t\t\t\treturn \"-\" + this.negate().toString(radix);\n\t\t\t}\n\t\t}\n\n\t\t// Do several (6) digits each time through the loop, so as to\n\t\t// minimize the calls to the very expensive emulated div.\n\t\tconst radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);\n\t\tlet result = \"\";\n\t\tlet rem = this as Long;\n\t\twhile (true) {\n\t\t\tconst remDiv = rem.divide(radixToPower);\n\t\t\tconst intval = rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0;\n\t\t\tlet digits = intval.toString(radix);\n\t\t\trem = remDiv;\n\t\t\tif (rem.isZero()) {\n\t\t\t\treturn digits + result;\n\t\t\t} else {\n\t\t\t\twhile (digits.length < 6) {\n\t\t\t\t\tdigits = \"0\" + digits;\n\t\t\t\t}\n\t\t\t\tresult = \"\" + digits + result;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Gets the high 32 bits as a signed integer.\n\tgetHighBits() {\n\t\treturn this.high;\n\t}\n\n\t// Gets the high 32 bits as an unsigned integer.\n\tgetHighBitsUnsigned() {\n\t\treturn this.high >>> 0;\n\t}\n\n\t// Gets the low 32 bits as a signed integer.\n\tgetLowBits() {\n\t\treturn this.low;\n\t}\n\n\t// Gets the low 32 bits as an unsigned integer.\n\tgetLowBitsUnsigned() {\n\t\treturn this.low >>> 0;\n\t}\n\n\t// Gets the number of bits needed to represent the absolute value of this Long.\n\tgetNumBitsAbs(): number {\n\t\tif (this.isNegative()) {\n\t\t\t// Unsigned Longs are never negative\n\t\t\treturn this.equals(Long.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();\n\t\t}\n\t\tconst val = this.high != 0 ? this.high : this.low;\n\t\tlet bit;\n\t\tfor (bit = 31; bit > 0; bit--) {\n\t\t\tif ((val & (1 << bit)) != 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn this.high != 0 ? bit + 33 : bit + 1;\n\t}\n\n\tisZero() {\n\t\treturn this.high === 0 && this.low === 0;\n\t}\n\n\tisNegative() {\n\t\treturn !this.unsigned && this.high < 0;\n\t}\n\n\tisPositive() {\n\t\treturn this.unsigned || this.high >= 0;\n\t}\n\n\tisOdd() {\n\t\treturn (this.low & 1) === 1;\n\t}\n\n\tisEven() {\n\t\treturn (this.low & 1) === 0;\n\t}\n\n\tequals(other: Long | number | string) {\n\t\tif (!(other instanceof Long)) {\n\t\t\tother = Long.fromValue(other);\n\t\t}\n\t\tif (\n\t\t\tthis.unsigned !== other.unsigned &&\n\t\t\tthis.high >>> 31 === 1 &&\n\t\t\tother.high >>> 31 === 1\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.high === other.high && this.low === other.low;\n\t}\n\n\tnotEquals(other: Long | number | string) {\n\t\treturn !this.equals(other);\n\t}\n\n\tlessThan(other: Long | number | string) {\n\t\treturn this.compare(other) < 0;\n\t}\n\n\tlessThanOrEqual(other: Long | number | string) {\n\t\treturn this.compare(other) <= 0;\n\t}\n\n\tgreaterThan(other: Long | number | string) {\n\t\treturn this.compare(other) > 0;\n\t}\n\n\tgreaterThanOrEqual(other: Long | number | string) {\n\t\treturn this.compare(other) >= 0;\n\t}\n\n\t// Compares this Long's value with the specified's.\n\tcompare(other: Long | number | string) {\n\t\tif (!(other instanceof Long)) {\n\t\t\tother = Long.fromValue(other);\n\t\t}\n\t\tif (this.equals(other)) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst thisNeg = this.isNegative();\n\t\tconst otherNeg = other.isNegative();\n\t\tif (thisNeg && !otherNeg) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!thisNeg && otherNeg) {\n\t\t\treturn 1;\n\t\t}\n\t\t// At this point the sign bits are the same\n\t\tif (!this.unsigned) {\n\t\t\treturn this.subtract(other).isNegative() ? -1 : 1;\n\t\t}\n\t\t// Both are positive if at least one is unsigned\n\t\treturn other.high >>> 0 > this.high >>> 0 ||\n\t\t\t(other.high === this.high && other.low >>> 0 > this.low >>> 0)\n\t\t\t? -1\n\t\t\t: 1;\n\t}\n\n\t// Negates this Long's value.\n\tnegate() {\n\t\tif (!this.unsigned && this.equals(Long.MIN_VALUE)) {\n\t\t\treturn Long.MIN_VALUE;\n\t\t}\n\t\treturn this.not().add(Long.ONE);\n\t}\n\n\t// Returns the sum of this and the specified Long.\n\tadd(addend: Long | number | string) {\n\t\tif (!(addend instanceof Long)) {\n\t\t\taddend = Long.fromValue(addend);\n\t\t}\n\n\t\t// Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n\t\tconst a48 = this.high >>> 16;\n\t\tconst a32 = this.high & 0xffff;\n\t\tconst a16 = this.low >>> 16;\n\t\tconst a00 = this.low & 0xffff;\n\n\t\tconst b48 = addend.high >>> 16;\n\t\tconst b32 = addend.high & 0xffff;\n\t\tconst b16 = addend.low >>> 16;\n\t\tconst b00 = addend.low & 0xffff;\n\n\t\tlet c48 = 0;\n\t\tlet c32 = 0;\n\t\tlet c16 = 0;\n\t\tlet c00 = 0;\n\t\tc00 += a00 + b00;\n\t\tc16 += c00 >>> 16;\n\t\tc00 &= 0xffff;\n\t\tc16 += a16 + b16;\n\t\tc32 += c16 >>> 16;\n\t\tc16 &= 0xffff;\n\t\tc32 += a32 + b32;\n\t\tc48 += c32 >>> 16;\n\t\tc32 &= 0xffff;\n\t\tc48 += a48 + b48;\n\t\tc48 &= 0xffff;\n\t\treturn Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n\t}\n\n\t// Returns the difference of this and the specified Long.\n\tsubtract(subtrahend: Long | number | string) {\n\t\tif (!(subtrahend instanceof Long)) {\n\t\t\tsubtrahend = Long.fromValue(subtrahend);\n\t\t}\n\t\treturn this.add(subtrahend.negate());\n\t}\n\n\t// Returns the product of this and the specified Long.\n\tmultiply(multiplier: Long | number | string): Long {\n\t\tif (this.isZero()) {\n\t\t\treturn Long.ZERO;\n\t\t}\n\t\tif (!(multiplier instanceof Long)) {\n\t\t\tmultiplier = Long.fromValue(multiplier);\n\t\t}\n\n\t\tif (multiplier.isZero()) {\n\t\t\treturn Long.ZERO;\n\t\t}\n\t\tif (this.equals(Long.MIN_VALUE)) {\n\t\t\treturn multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n\t\t}\n\t\tif (multiplier.equals(Long.MIN_VALUE)) {\n\t\t\treturn this.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n\t\t}\n\n\t\tif (this.isNegative()) {\n\t\t\tif (multiplier.isNegative()) {\n\t\t\t\treturn this.negate().multiply(multiplier.negate());\n\t\t\t} else {\n\t\t\t\treturn this.negate().multiply(multiplier).negate();\n\t\t\t}\n\t\t} else if (multiplier.isNegative()) {\n\t\t\treturn this.multiply(multiplier.negate()).negate();\n\t\t}\n\n\t\t// If both longs are small, use float multiplication\n\t\tif (this.lessThan(TWO_PWR_24) && multiplier.lessThan(TWO_PWR_24)) {\n\t\t\treturn Long.fromNumber(\n\t\t\t\tthis.toNumber() * multiplier.toNumber(),\n\t\t\t\tthis.unsigned\n\t\t\t);\n\t\t}\n\n\t\t// Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n\t\t// We can skip products that would overflow.\n\n\t\tconst a48 = this.high >>> 16;\n\t\tconst a32 = this.high & 0xffff;\n\t\tconst a16 = this.low >>> 16;\n\t\tconst a00 = this.low & 0xffff;\n\n\t\tconst b48 = multiplier.high >>> 16;\n\t\tconst b32 = multiplier.high & 0xffff;\n\t\tconst b16 = multiplier.low >>> 16;\n\t\tconst b00 = multiplier.low & 0xffff;\n\n\t\tlet c48 = 0;\n\t\tlet c32 = 0;\n\t\tlet c16 = 0;\n\t\tlet c00 = 0;\n\t\tc00 += a00 * b00;\n\t\tc16 += c00 >>> 16;\n\t\tc00 &= 0xffff;\n\t\tc16 += a16 * b00;\n\t\tc32 += c16 >>> 16;\n\t\tc16 &= 0xffff;\n\t\tc16 += a00 * b16;\n\t\tc32 += c16 >>> 16;\n\t\tc16 &= 0xffff;\n\t\tc32 += a32 * b00;\n\t\tc48 += c32 >>> 16;\n\t\tc32 &= 0xffff;\n\t\tc32 += a16 * b16;\n\t\tc48 += c32 >>> 16;\n\t\tc32 &= 0xffff;\n\t\tc32 += a00 * b32;\n\t\tc48 += c32 >>> 16;\n\t\tc32 &= 0xffff;\n\t\tc48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n\t\tc48 &= 0xffff;\n\t\treturn Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n\t}\n\n\t// Returns this Long divided by the specified. The result is signed if this Long is signed or unsigned if this Long is unsigned.\n\tdivide(divisor: Long | number | string): Long {\n\t\tif (!(divisor instanceof Long)) {\n\t\t\tdivisor = Long.fromValue(divisor);\n\t\t}\n\t\tif (divisor.isZero()) {\n\t\t\tthrow Error(\"division by zero\");\n\t\t}\n\n\t\tif (this.isZero()) {\n\t\t\treturn this.unsigned ? Long.UZERO : Long.ZERO;\n\t\t}\n\t\tlet approx;\n\t\tlet rem;\n\t\tlet res;\n\t\tif (!this.unsigned) {\n\t\t\t// This section is only relevant for signed longs and is derived from the\n\t\t\t// closure library as a whole.\n\t\t\tif (this.equals(Long.MIN_VALUE)) {\n\t\t\t\tif (divisor.equals(Long.ONE) || divisor.equals(Long.NEG_ONE)) {\n\t\t\t\t\treturn Long.MIN_VALUE;\n\t\t\t\t}\n\t\t\t\t// recall that -MIN_VALUE == MIN_VALUE\n\t\t\t\telse if (divisor.equals(Long.MIN_VALUE)) {\n\t\t\t\t\treturn Long.ONE;\n\t\t\t\t} else {\n\t\t\t\t\t// At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n\t\t\t\t\tconst halfThis = this.shiftRight(1);\n\t\t\t\t\tapprox = halfThis.divide(divisor).shiftLeft(1);\n\t\t\t\t\tif (approx.equals(Long.ZERO)) {\n\t\t\t\t\t\treturn divisor.isNegative() ? Long.ONE : Long.NEG_ONE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trem = this.subtract(divisor.multiply(approx));\n\t\t\t\t\t\tres = approx.add(rem.divide(divisor));\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (divisor.equals(Long.MIN_VALUE)) {\n\t\t\t\treturn this.unsigned ? Long.UZERO : Long.ZERO;\n\t\t\t}\n\t\t\tif (this.isNegative()) {\n\t\t\t\tif (divisor.isNegative()) {\n\t\t\t\t\treturn this.negate().divide(divisor.negate());\n\t\t\t\t}\n\t\t\t\treturn this.negate().divide(divisor).negate();\n\t\t\t} else if (divisor.isNegative()) {\n\t\t\t\treturn this.divide(divisor.negate()).negate();\n\t\t\t}\n\t\t\tres = Long.ZERO;\n\t\t} else {\n\t\t\t// The algorithm below has not been made for unsigned longs. It's therefore\n\t\t\t// required to take special care of the MSB prior to running it.\n\t\t\tif (!divisor.unsigned) {\n\t\t\t\tdivisor = divisor.toUnsigned();\n\t\t\t}\n\t\t\tif (divisor.greaterThan(this)) {\n\t\t\t\treturn Long.UZERO;\n\t\t\t}\n\t\t\tif (divisor.greaterThan(this.shiftRightUnsigned(1))) {\n\t\t\t\t// 15 >>> 1 = 7 ; with divisor = 8 ; true\n\t\t\t\treturn Long.UONE;\n\t\t\t}\n\t\t\tres = Long.UZERO;\n\t\t}\n\n\t\t// Repeat the following until the remainder is less than other:  find a\n\t\t// floating-point that approximates remainder / other *from below*, add this\n\t\t// into the result, and subtract it from the remainder.  It is critical that\n\t\t// the approximate value is less than or equal to the real value so that the\n\t\t// remainder never becomes negative.\n\t\trem = this;\n\t\twhile (rem.greaterThanOrEqual(divisor)) {\n\t\t\t// Approximate the result of division. This may be a little greater or\n\t\t\t// smaller than the actual value.\n\t\t\tapprox = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n\n\t\t\t// We will tweak the approximate result by changing it in the 48-th digit or\n\t\t\t// the smallest non-fractional digit, whichever is larger.\n\t\t\tconst log2 = Math.ceil(Math.log(approx) / Math.LN2);\n\t\t\tconst delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n\t\t\t// Decrease the approximation until it is smaller than the remainder.  Note\n\t\t\t// that if it is too large, the product overflows and is negative.\n\t\t\tlet approxRes = Long.fromNumber(approx);\n\t\t\tlet approxRem = approxRes.multiply(divisor);\n\t\t\twhile (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n\t\t\t\tapprox -= delta;\n\t\t\t\tapproxRes = Long.fromNumber(approx, this.unsigned);\n\t\t\t\tapproxRem = approxRes.multiply(divisor);\n\t\t\t}\n\n\t\t\t// We know the answer can't be zero... and actually, zero would cause\n\t\t\t// infinite recursion since we would make no progress.\n\t\t\tif (approxRes.isZero()) {\n\t\t\t\tapproxRes = Long.ONE;\n\t\t\t}\n\n\t\t\tres = res.add(approxRes);\n\t\t\trem = rem.subtract(approxRem);\n\t\t}\n\t\treturn res;\n\t}\n\n\t// Returns this Long modulo the specified.\n\tmodulo(divisor: Long | number | string) {\n\t\tif (!(divisor instanceof Long)) {\n\t\t\tdivisor = Long.fromValue(divisor);\n\t\t}\n\n\t\treturn this.subtract(this.divide(divisor).multiply(divisor));\n\t}\n\n\t// Returns the bitwise NOT of this Long.\n\tnot() {\n\t\treturn Long.fromBits(~this.low, ~this.high, this.unsigned);\n\t}\n\n\t// Returns the bitwise AND of this Long and the specified.\n\tand(other: Long | number | string) {\n\t\tif (!(other instanceof Long)) {\n\t\t\tother = Long.fromValue(other);\n\t\t}\n\t\treturn Long.fromBits(\n\t\t\tthis.low & other.low,\n\t\t\tthis.high & other.high,\n\t\t\tthis.unsigned\n\t\t);\n\t}\n\n\t// Returns the bitwise OR of this Long and the specified.\n\tor(other: Long | number | string) {\n\t\tif (!(other instanceof Long)) {\n\t\t\tother = Long.fromValue(other);\n\t\t}\n\t\treturn Long.fromBits(\n\t\t\tthis.low | other.low,\n\t\t\tthis.high | other.high,\n\t\t\tthis.unsigned\n\t\t);\n\t}\n\n\t// Returns the bitwise XOR of this Long and the given one.\n\txor(other: Long | number | string) {\n\t\tif (!(other instanceof Long)) {\n\t\t\tother = Long.fromValue(other);\n\t\t}\n\t\treturn Long.fromBits(\n\t\t\tthis.low ^ other.low,\n\t\t\tthis.high ^ other.high,\n\t\t\tthis.unsigned\n\t\t);\n\t}\n\n\t// Returns this Long with bits shifted to the left by the given amount.\n\tshiftLeft(numBits: number | Long) {\n\t\tif (numBits instanceof Long) {\n\t\t\tnumBits = numBits.toInt();\n\t\t}\n\t\tif ((numBits &= 63) === 0) {\n\t\t\treturn this;\n\t\t} else if (numBits < 32) {\n\t\t\treturn Long.fromBits(\n\t\t\t\tthis.low << numBits,\n\t\t\t\t(this.high << numBits) | (this.low >>> (32 - numBits)),\n\t\t\t\tthis.unsigned\n\t\t\t);\n\t\t} else {\n\t\t\treturn Long.fromBits(0, this.low << (numBits - 32), this.unsigned);\n\t\t}\n\t}\n\n\t// Returns this Long with bits arithmetically shifted to the right by the given amount.\n\tshiftRight(numBits: number | Long) {\n\t\tif (numBits instanceof Long) {\n\t\t\tnumBits = numBits.toInt();\n\t\t}\n\t\tif ((numBits &= 63) === 0) {\n\t\t\treturn this;\n\t\t} else if (numBits < 32) {\n\t\t\treturn Long.fromBits(\n\t\t\t\t(this.low >>> numBits) | (this.high << (32 - numBits)),\n\t\t\t\tthis.high >> numBits,\n\t\t\t\tthis.unsigned\n\t\t\t);\n\t\t} else {\n\t\t\treturn Long.fromBits(\n\t\t\t\tthis.high >> (numBits - 32),\n\t\t\t\tthis.high >= 0 ? 0 : -1,\n\t\t\t\tthis.unsigned\n\t\t\t);\n\t\t}\n\t}\n\n\t// Returns this Long with bits logically shifted to the right by the given amount.\n\tshiftRightUnsigned(numBits: number | Long) {\n\t\tif (numBits instanceof Long) {\n\t\t\tnumBits = numBits.toInt();\n\t\t}\n\t\tif ((numBits &= 63) === 0) {\n\t\t\treturn this;\n\t\t}\n\t\tif (numBits < 32) {\n\t\t\treturn Long.fromBits(\n\t\t\t\t(this.low >>> numBits) | (this.high << (32 - numBits)),\n\t\t\t\tthis.high >>> numBits,\n\t\t\t\tthis.unsigned\n\t\t\t);\n\t\t}\n\t\tif (numBits === 32) {\n\t\t\treturn Long.fromBits(this.high, 0, this.unsigned);\n\t\t}\n\t\treturn Long.fromBits(this.high >>> (numBits - 32), 0, this.unsigned);\n\t}\n\n\t// Returns this Long with bits rotated to the left by the given amount.\n\trotateLeft(numBits: number | Long) {\n\t\tlet b;\n\t\tif (numBits instanceof Long) {\n\t\t\tnumBits = numBits.toInt();\n\t\t}\n\t\tif ((numBits &= 63) === 0) {\n\t\t\treturn this;\n\t\t}\n\t\tif (numBits === 32) {\n\t\t\treturn Long.fromBits(this.high, this.low, this.unsigned);\n\t\t}\n\t\tif (numBits < 32) {\n\t\t\tb = 32 - numBits;\n\t\t\treturn Long.fromBits(\n\t\t\t\t(this.low << numBits) | (this.high >>> b),\n\t\t\t\t(this.high << numBits) | (this.low >>> b),\n\t\t\t\tthis.unsigned\n\t\t\t);\n\t\t}\n\t\tnumBits -= 32;\n\t\tb = 32 - numBits;\n\t\treturn Long.fromBits(\n\t\t\t(this.high << numBits) | (this.low >>> b),\n\t\t\t(this.low << numBits) | (this.high >>> b),\n\t\t\tthis.unsigned\n\t\t);\n\t}\n\n\t// Returns this Long with bits rotated to the right by the given amount.\n\trotateRight(numBits: number | Long) {\n\t\tlet b;\n\t\tif (numBits instanceof Long) {\n\t\t\tnumBits = numBits.toInt();\n\t\t}\n\t\tif ((numBits &= 63) === 0) {\n\t\t\treturn this;\n\t\t}\n\t\tif (numBits === 32) {\n\t\t\treturn Long.fromBits(this.high, this.low, this.unsigned);\n\t\t}\n\t\tif (numBits < 32) {\n\t\t\tb = 32 - numBits;\n\t\t\treturn Long.fromBits(\n\t\t\t\t(this.high << b) | (this.low >>> numBits),\n\t\t\t\t(this.low << b) | (this.high >>> numBits),\n\t\t\t\tthis.unsigned\n\t\t\t);\n\t\t}\n\t\tnumBits -= 32;\n\t\tb = 32 - numBits;\n\t\treturn Long.fromBits(\n\t\t\t(this.low << b) | (this.high >>> numBits),\n\t\t\t(this.high << b) | (this.low >>> numBits),\n\t\t\tthis.unsigned\n\t\t);\n\t}\n\n\t// Converts this Long to signed.\n\ttoSigned() {\n\t\tif (!this.unsigned) {\n\t\t\treturn this;\n\t\t}\n\t\treturn Long.fromBits(this.low, this.high, false);\n\t}\n\n\t//Converts this Long to unsigned.\n\ttoUnsigned() {\n\t\tif (this.unsigned) {\n\t\t\treturn this;\n\t\t}\n\t\treturn Long.fromBits(this.low, this.high, true);\n\t}\n\n\t// Converts this Long to its byte representation.\n\ttoBytes(le?: boolean) {\n\t\treturn le ? this.toBytesLE() : this.toBytesBE();\n\t}\n\n\t//Converts this Long to its little endian byte representation.\n\ttoBytesLE() {\n\t\tconst hi = this.high;\n\t\tconst lo = this.low;\n\t\treturn [\n\t\t\tlo & 0xff,\n\t\t\t(lo >>> 8) & 0xff,\n\t\t\t(lo >>> 16) & 0xff,\n\t\t\tlo >>> 24,\n\t\t\thi & 0xff,\n\t\t\t(hi >>> 8) & 0xff,\n\t\t\t(hi >>> 16) & 0xff,\n\t\t\thi >>> 24,\n\t\t];\n\t}\n\n\t// Converts this Long to its big endian byte representation.\n\ttoBytesBE() {\n\t\tconst hi = this.high;\n\t\tconst lo = this.low;\n\t\treturn [\n\t\t\thi >>> 24,\n\t\t\t(hi >>> 16) & 0xff,\n\t\t\t(hi >>> 8) & 0xff,\n\t\t\thi & 0xff,\n\t\t\tlo >>> 24,\n\t\t\t(lo >>> 16) & 0xff,\n\t\t\t(lo >>> 8) & 0xff,\n\t\t\tlo & 0xff,\n\t\t];\n\t}\n\n\t// Creates a Long from its byte representation.\n\tstatic fromBytes(bytes: number[], unsigned?: boolean, le?: boolean) {\n\t\treturn le\n\t\t\t? Long.fromBytesLE(bytes, unsigned)\n\t\t\t: Long.fromBytesBE(bytes, unsigned);\n\t}\n\n\t// Creates a Long from its little endian byte representation.\n\tstatic fromBytesLE(bytes: number[], unsigned?: boolean) {\n\t\treturn new Long(\n\t\t\tbytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24),\n\t\t\tbytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24),\n\t\t\tunsigned\n\t\t);\n\t}\n\n\t// Creates a Long from its big endian byte representation.\n\tstatic fromBytesBE(bytes: number[], unsigned?: boolean) {\n\t\treturn new Long(\n\t\t\t(bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7],\n\t\t\t(bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3],\n\t\t\tunsigned\n\t\t);\n\t}\n\n\tstatic fromInt(value: number, unsigned?: boolean) {\n\t\tlet cache;\n\t\tif (unsigned) {\n\t\t\tvalue >>>= 0;\n\t\t\tif ((cache = 0 <= value && value < 256)) {\n\t\t\t\tconst cachedObj = UINT_CACHE[value];\n\t\t\t\tif (cachedObj) {\n\t\t\t\t\treturn cachedObj;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n\t\t\tif (cache) {\n\t\t\t\tUINT_CACHE[value] = obj;\n\t\t\t}\n\t\t\treturn obj;\n\t\t} else {\n\t\t\tvalue |= 0;\n\t\t\tif ((cache = -128 <= value && value < 128)) {\n\t\t\t\tconst cachedObj = INT_CACHE[value];\n\t\t\t\tif (cachedObj) {\n\t\t\t\t\treturn cachedObj;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst obj = Long.fromBits(value, value < 0 ? -1 : 0, false);\n\t\t\tif (cache) {\n\t\t\t\tINT_CACHE[value] = obj;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t}\n\n\tstatic fromNumber(value: number, unsigned?: boolean): Long {\n\t\tif (isNaN(value)) {\n\t\t\treturn unsigned ? Long.UZERO : Long.ZERO;\n\t\t}\n\t\tif (unsigned) {\n\t\t\tif (value < 0) {\n\t\t\t\treturn Long.UZERO;\n\t\t\t}\n\t\t\tif (value >= TWO_PWR_64_DBL) {\n\t\t\t\treturn Long.MAX_UNSIGNED_VALUE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (value <= -TWO_PWR_63_DBL) {\n\t\t\t\treturn Long.MIN_VALUE;\n\t\t\t}\n\t\t\tif (value + 1 >= TWO_PWR_63_DBL) {\n\t\t\t\treturn Long.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tif (value < 0) {\n\t\t\treturn Long.fromNumber(-value, unsigned).negate();\n\t\t}\n\t\treturn Long.fromBits(\n\t\t\tvalue % TWO_PWR_32_DBL | 0,\n\t\t\t(value / TWO_PWR_32_DBL) | 0,\n\t\t\tunsigned\n\t\t);\n\t}\n\n\tstatic fromBits(lowBits: number, highBits: number, unsigned?: boolean) {\n\t\treturn new Long(lowBits, highBits, unsigned);\n\t}\n\n\tstatic fromString(\n\t\tstr: string,\n\t\tunsigned?: boolean | number,\n\t\tradix?: number\n\t): Long {\n\t\tif (str.length === 0) {\n\t\t\tthrow Error(\"empty string\");\n\t\t}\n\t\tif (\n\t\t\tstr === \"NaN\" ||\n\t\t\tstr === \"Infinity\" ||\n\t\t\tstr === \"+Infinity\" ||\n\t\t\tstr === \"-Infinity\"\n\t\t) {\n\t\t\treturn Long.ZERO;\n\t\t}\n\t\tif (typeof unsigned === \"number\") {\n\t\t\t// For goog.math.long compatibility\n\t\t\t(radix = unsigned), (unsigned = false);\n\t\t} else {\n\t\t\tunsigned = !!unsigned;\n\t\t}\n\t\tradix = radix || 10;\n\t\tif (radix < 2 || 36 < radix) {\n\t\t\tthrow RangeError(\"radix\");\n\t\t}\n\n\t\tlet p;\n\t\tif ((p = str.indexOf(\"-\")) > 0) {\n\t\t\tthrow Error(\"interior hyphen\");\n\t\t} else if (p === 0) {\n\t\t\treturn Long.fromString(str.substring(1), unsigned, radix).negate();\n\t\t}\n\n\t\t// Do several (8) digits each time through the loop, so as to\n\t\t// minimize the calls to the very expensive emulated div.\n\t\tconst radixToPower = Long.fromNumber(Math.pow(radix, 8));\n\n\t\tlet result = Long.ZERO;\n\t\tfor (let i = 0; i < str.length; i += 8) {\n\t\t\tconst size = Math.min(8, str.length - i);\n\t\t\tconst value = parseInt(str.substring(i, i + size), radix);\n\t\t\tif (size < 8) {\n\t\t\t\tconst power = Long.fromNumber(Math.pow(radix, size));\n\t\t\t\tresult = result.multiply(power).add(Long.fromNumber(value));\n\t\t\t} else {\n\t\t\t\tresult = result.multiply(radixToPower);\n\t\t\t\tresult = result.add(Long.fromNumber(value));\n\t\t\t}\n\t\t}\n\t\tresult.unsigned = unsigned;\n\t\treturn result;\n\t}\n\n\tstatic fromValue(\n\t\tval:\n\t\t\t| Long\n\t\t\t| number\n\t\t\t| string\n\t\t\t| { low: number; high: number; unsigned: boolean },\n\t\tunsigned?: boolean\n\t) {\n\t\tif (typeof val === \"number\") {\n\t\t\treturn Long.fromNumber(val, unsigned);\n\t\t}\n\t\tif (typeof val === \"string\") {\n\t\t\treturn Long.fromString(val, unsigned);\n\t\t}\n\t\treturn Long.fromBits(\n\t\t\tval.low,\n\t\t\tval.high,\n\t\t\ttypeof unsigned === \"boolean\" ? unsigned : val.unsigned\n\t\t);\n\t}\n}\n\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_24_DBL = 1 << 24;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\nconst TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);\n"],"names":["INT_CACHE","UINT_CACHE","Long","constructor","low","high","unsigned","this","toInt","toNumber","TWO_PWR_32_DBL","toString","radix","RangeError","isZero","isNegative","equals","MIN_VALUE","radixLong","fromNumber","div","divide","rem1","multiply","subtract","negate","radixToPower","Math","pow","result","rem","remDiv","digits","length","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","val","bit","isPositive","isOdd","isEven","other","fromValue","notEquals","lessThan","compare","lessThanOrEqual","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","not","add","ONE","addend","c48","c32","c16","c00","fromBits","subtrahend","multiplier","ZERO","TWO_PWR_24","a32","a16","a00","b32","b16","b00","divisor","Error","UZERO","approx","res","toUnsigned","shiftRightUnsigned","UONE","NEG_ONE","shiftRight","shiftLeft","max","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","modulo","and","or","xor","numBits","rotateLeft","b","rotateRight","toSigned","toBytes","le","toBytesLE","toBytesBE","hi","lo","static","bytes","fromBytesLE","fromBytesBE","value","cache","cachedObj","obj","isNaN","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","MAX_VALUE","lowBits","highBits","str","p","indexOf","fromString","substring","i","size","min","parseInt","power","fromInt","TWO_PWR_16_DBL"],"mappings":"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"}