{"version":3,"file":"long.umd.js","sources":["../src/long.ts"],"sourcesContent":["const INT_CACHE: Record<number, Long> = {};\nconst UINT_CACHE: Record<number, Long> = {};\n\nexport class Long {\n\tstatic readonly ZERO = Long.fromInt(0);\n\n\tstatic readonly UZERO = Long.fromInt(0, true);\n\n\tstatic readonly ONE = Long.fromInt(1);\n\n\tstatic readonly UONE = Long.fromInt(1, true);\n\n\tstatic readonly NEG_ONE = Long.fromInt(-1);\n\n\tstatic readonly MAX_VALUE = Long.fromBits(\n\t\t0xffffffff | 0,\n\t\t0x7fffffff | 0,\n\t\tfalse\n\t);\n\n\tstatic readonly MAX_UNSIGNED_VALUE = Long.fromBits(\n\t\t0xffffffff | 0,\n\t\t0xffffffff | 0,\n\t\ttrue\n\t);\n\n\tstatic readonly MIN_VALUE = Long.fromBits(0, 0x80000000 | 0, false);\n\n\tlow: number;\n\n\thigh: number;\n\n\tunsigned: boolean;\n\n\tconstructor(low: number, high: number, unsigned = false) {\n\t\tthis.low = low | 0;\n\t\tthis.high = high | 0;\n\t\tthis.unsigned = unsigned;\n\t}\n\n\t// Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n\ttoInt() {\n\t\treturn this.unsigned ? this.low >>> 0 : this.low;\n\t}\n\n\t// Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n\ttoNumber() {\n\t\tif (this.unsigned) {\n\t\t\treturn (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n\t\t}\n\t\treturn this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n\t}\n\n\t// Converts the Long to a string written in the specified radix.\n\ttoString(radix = 10): string {\n\t\tif (radix < 2 || 36 < radix) {\n\t\t\tthrow RangeError(\"radix\");\n\t\t}\n\t\tif (this.isZero()) {\n\t\t\treturn \"0\";\n\t\t}\n\t\tif (this.isNegative()) {\n\t\t\t// Unsigned Longs are never negative\n\t\t\tif (this.equals(Long.MIN_VALUE)) {\n\t\t\t\t// We need to change the Long value before it can be negated, so we remove\n\t\t\t\t// the bottom-most digit in this base and then recurse to do the rest.\n\t\t\t\tconst radixLong = Long.fromNumber(radix);\n\t\t\t\tconst div = this.divide(radixLong);\n\t\t\t\tconst rem1 = div.multiply(radixLong).subtract(this);\n\t\t\t\treturn div.toString(radix) + rem1.toInt().toString(radix);\n\t\t\t} else {\n\t\t\t\treturn \"-\" + this.negate().toString(radix);\n\t\t\t}\n\t\t}\n\n\t\t// Do several (6) digits each time through the loop, so as to\n\t\t// minimize the calls to the very expensive emulated div.\n\t\tconst radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);\n\t\tlet result = \"\";\n\t\tlet rem = this as Long;\n\t\twhile (true) {\n\t\t\tconst remDiv = rem.divide(radixToPower);\n\t\t\tconst intval = rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0;\n\t\t\tlet digits = intval.toString(radix);\n\t\t\trem = remDiv;\n\t\t\tif (rem.isZero()) {\n\t\t\t\treturn digits + result;\n\t\t\t} else {\n\t\t\t\twhile (digits.length < 6) {\n\t\t\t\t\tdigits = \"0\" + digits;\n\t\t\t\t}\n\t\t\t\tresult = \"\" + digits + result;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Gets the high 32 bits as a signed integer.\n\tgetHighBits() {\n\t\treturn this.high;\n\t}\n\n\t// Gets the high 32 bits as an unsigned integer.\n\tgetHighBitsUnsigned() {\n\t\treturn this.high >>> 0;\n\t}\n\n\t// Gets the low 32 bits as a signed integer.\n\tgetLowBits() {\n\t\treturn this.low;\n\t}\n\n\t// Gets the low 32 bits as an unsigned integer.\n\tgetLowBitsUnsigned() {\n\t\treturn this.low >>> 0;\n\t}\n\n\t// Gets the number of bits needed to represent the absolute value of this Long.\n\tgetNumBitsAbs(): number {\n\t\tif (this.isNegative()) {\n\t\t\t// Unsigned Longs are never negative\n\t\t\treturn this.equals(Long.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();\n\t\t}\n\t\tconst val = this.high != 0 ? this.high : this.low;\n\t\tlet bit;\n\t\tfor (bit = 31; bit > 0; bit--) {\n\t\t\tif ((val & (1 << bit)) != 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn this.high != 0 ? bit + 33 : bit + 1;\n\t}\n\n\tisZero() {\n\t\treturn this.high === 0 && this.low === 0;\n\t}\n\n\tisNegative() {\n\t\treturn !this.unsigned && this.high < 0;\n\t}\n\n\tisPositive() {\n\t\treturn this.unsigned || this.high >= 0;\n\t}\n\n\tisOdd() {\n\t\treturn (this.low & 1) === 1;\n\t}\n\n\tisEven() {\n\t\treturn (this.low & 1) === 0;\n\t}\n\n\tequals(other: Long | number | string) {\n\t\tif (!(other instanceof Long)) {\n\t\t\tother = Long.fromValue(other);\n\t\t}\n\t\tif (\n\t\t\tthis.unsigned !== other.unsigned &&\n\t\t\tthis.high >>> 31 === 1 &&\n\t\t\tother.high >>> 31 === 1\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.high === other.high && this.low === other.low;\n\t}\n\n\tnotEquals(other: Long | number | string) {\n\t\treturn !this.equals(other);\n\t}\n\n\tlessThan(other: Long | number | string) {\n\t\treturn this.compare(other) < 0;\n\t}\n\n\tlessThanOrEqual(other: Long | number | string) {\n\t\treturn this.compare(other) <= 0;\n\t}\n\n\tgreaterThan(other: Long | number | string) {\n\t\treturn this.compare(other) > 0;\n\t}\n\n\tgreaterThanOrEqual(other: Long | number | string) {\n\t\treturn this.compare(other) >= 0;\n\t}\n\n\t// Compares this Long's value with the specified's.\n\tcompare(other: Long | number | string) {\n\t\tif (!(other instanceof Long)) {\n\t\t\tother = Long.fromValue(other);\n\t\t}\n\t\tif (this.equals(other)) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst thisNeg = this.isNegative();\n\t\tconst otherNeg = other.isNegative();\n\t\tif (thisNeg && !otherNeg) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!thisNeg && otherNeg) {\n\t\t\treturn 1;\n\t\t}\n\t\t// At this point the sign bits are the same\n\t\tif (!this.unsigned) {\n\t\t\treturn this.subtract(other).isNegative() ? -1 : 1;\n\t\t}\n\t\t// Both are positive if at least one is unsigned\n\t\treturn other.high >>> 0 > this.high >>> 0 ||\n\t\t\t(other.high === this.high && other.low >>> 0 > this.low >>> 0)\n\t\t\t? -1\n\t\t\t: 1;\n\t}\n\n\t// Negates this Long's value.\n\tnegate() {\n\t\tif (!this.unsigned && this.equals(Long.MIN_VALUE)) {\n\t\t\treturn Long.MIN_VALUE;\n\t\t}\n\t\treturn this.not().add(Long.ONE);\n\t}\n\n\t// Returns the sum of this and the specified Long.\n\tadd(addend: Long | number | string) {\n\t\tif (!(addend instanceof Long)) {\n\t\t\taddend = Long.fromValue(addend);\n\t\t}\n\n\t\t// Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n\t\tconst a48 = this.high >>> 16;\n\t\tconst a32 = this.high & 0xffff;\n\t\tconst a16 = this.low >>> 16;\n\t\tconst a00 = this.low & 0xffff;\n\n\t\tconst b48 = addend.high >>> 16;\n\t\tconst b32 = addend.high & 0xffff;\n\t\tconst b16 = addend.low >>> 16;\n\t\tconst b00 = addend.low & 0xffff;\n\n\t\tlet c48 = 0;\n\t\tlet c32 = 0;\n\t\tlet c16 = 0;\n\t\tlet c00 = 0;\n\t\tc00 += a00 + b00;\n\t\tc16 += c00 >>> 16;\n\t\tc00 &= 0xffff;\n\t\tc16 += a16 + b16;\n\t\tc32 += c16 >>> 16;\n\t\tc16 &= 0xffff;\n\t\tc32 += a32 + b32;\n\t\tc48 += c32 >>> 16;\n\t\tc32 &= 0xffff;\n\t\tc48 += a48 + b48;\n\t\tc48 &= 0xffff;\n\t\treturn Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n\t}\n\n\t// Returns the difference of this and the specified Long.\n\tsubtract(subtrahend: Long | number | string) {\n\t\tif (!(subtrahend instanceof Long)) {\n\t\t\tsubtrahend = Long.fromValue(subtrahend);\n\t\t}\n\t\treturn this.add(subtrahend.negate());\n\t}\n\n\t// Returns the product of this and the specified Long.\n\tmultiply(multiplier: Long | number | string): Long {\n\t\tif (this.isZero()) {\n\t\t\treturn Long.ZERO;\n\t\t}\n\t\tif (!(multiplier instanceof Long)) {\n\t\t\tmultiplier = Long.fromValue(multiplier);\n\t\t}\n\n\t\tif (multiplier.isZero()) {\n\t\t\treturn Long.ZERO;\n\t\t}\n\t\tif (this.equals(Long.MIN_VALUE)) {\n\t\t\treturn multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n\t\t}\n\t\tif (multiplier.equals(Long.MIN_VALUE)) {\n\t\t\treturn this.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n\t\t}\n\n\t\tif (this.isNegative()) {\n\t\t\tif (multiplier.isNegative()) {\n\t\t\t\treturn this.negate().multiply(multiplier.negate());\n\t\t\t} else {\n\t\t\t\treturn this.negate().multiply(multiplier).negate();\n\t\t\t}\n\t\t} else if (multiplier.isNegative()) {\n\t\t\treturn this.multiply(multiplier.negate()).negate();\n\t\t}\n\n\t\t// If both longs are small, use float multiplication\n\t\tif (this.lessThan(TWO_PWR_24) && multiplier.lessThan(TWO_PWR_24)) {\n\t\t\treturn Long.fromNumber(\n\t\t\t\tthis.toNumber() * multiplier.toNumber(),\n\t\t\t\tthis.unsigned\n\t\t\t);\n\t\t}\n\n\t\t// Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n\t\t// We can skip products that would overflow.\n\n\t\tconst a48 = this.high >>> 16;\n\t\tconst a32 = this.high & 0xffff;\n\t\tconst a16 = this.low >>> 16;\n\t\tconst a00 = this.low & 0xffff;\n\n\t\tconst b48 = multiplier.high >>> 16;\n\t\tconst b32 = multiplier.high & 0xffff;\n\t\tconst b16 = multiplier.low >>> 16;\n\t\tconst b00 = multiplier.low & 0xffff;\n\n\t\tlet c48 = 0;\n\t\tlet c32 = 0;\n\t\tlet c16 = 0;\n\t\tlet c00 = 0;\n\t\tc00 += a00 * b00;\n\t\tc16 += c00 >>> 16;\n\t\tc00 &= 0xffff;\n\t\tc16 += a16 * b00;\n\t\tc32 += c16 >>> 16;\n\t\tc16 &= 0xffff;\n\t\tc16 += a00 * b16;\n\t\tc32 += c16 >>> 16;\n\t\tc16 &= 0xffff;\n\t\tc32 += a32 * b00;\n\t\tc48 += c32 >>> 16;\n\t\tc32 &= 0xffff;\n\t\tc32 += a16 * b16;\n\t\tc48 += c32 >>> 16;\n\t\tc32 &= 0xffff;\n\t\tc32 += a00 * b32;\n\t\tc48 += c32 >>> 16;\n\t\tc32 &= 0xffff;\n\t\tc48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n\t\tc48 &= 0xffff;\n\t\treturn Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n\t}\n\n\t// Returns this Long divided by the specified. The result is signed if this Long is signed or unsigned if this Long is unsigned.\n\tdivide(divisor: Long | number | string): Long {\n\t\tif (!(divisor instanceof Long)) {\n\t\t\tdivisor = Long.fromValue(divisor);\n\t\t}\n\t\tif (divisor.isZero()) {\n\t\t\tthrow Error(\"division by zero\");\n\t\t}\n\n\t\tif (this.isZero()) {\n\t\t\treturn this.unsigned ? Long.UZERO : Long.ZERO;\n\t\t}\n\t\tlet approx;\n\t\tlet rem;\n\t\tlet res;\n\t\tif (!this.unsigned) {\n\t\t\t// This section is only relevant for signed longs and is derived from the\n\t\t\t// closure library as a whole.\n\t\t\tif (this.equals(Long.MIN_VALUE)) {\n\t\t\t\tif (divisor.equals(Long.ONE) || divisor.equals(Long.NEG_ONE)) {\n\t\t\t\t\treturn Long.MIN_VALUE;\n\t\t\t\t}\n\t\t\t\t// recall that -MIN_VALUE == MIN_VALUE\n\t\t\t\telse if (divisor.equals(Long.MIN_VALUE)) {\n\t\t\t\t\treturn Long.ONE;\n\t\t\t\t} else {\n\t\t\t\t\t// At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n\t\t\t\t\tconst halfThis = this.shiftRight(1);\n\t\t\t\t\tapprox = halfThis.divide(divisor).shiftLeft(1);\n\t\t\t\t\tif (approx.equals(Long.ZERO)) {\n\t\t\t\t\t\treturn divisor.isNegative() ? Long.ONE : Long.NEG_ONE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trem = this.subtract(divisor.multiply(approx));\n\t\t\t\t\t\tres = approx.add(rem.divide(divisor));\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (divisor.equals(Long.MIN_VALUE)) {\n\t\t\t\treturn this.unsigned ? Long.UZERO : Long.ZERO;\n\t\t\t}\n\t\t\tif (this.isNegative()) {\n\t\t\t\tif (divisor.isNegative()) {\n\t\t\t\t\treturn this.negate().divide(divisor.negate());\n\t\t\t\t}\n\t\t\t\treturn this.negate().divide(divisor).negate();\n\t\t\t} else if (divisor.isNegative()) {\n\t\t\t\treturn this.divide(divisor.negate()).negate();\n\t\t\t}\n\t\t\tres = Long.ZERO;\n\t\t} else {\n\t\t\t// The algorithm below has not been made for unsigned longs. It's therefore\n\t\t\t// required to take special care of the MSB prior to running it.\n\t\t\tif (!divisor.unsigned) {\n\t\t\t\tdivisor = divisor.toUnsigned();\n\t\t\t}\n\t\t\tif (divisor.greaterThan(this)) {\n\t\t\t\treturn Long.UZERO;\n\t\t\t}\n\t\t\tif (divisor.greaterThan(this.shiftRightUnsigned(1))) {\n\t\t\t\t// 15 >>> 1 = 7 ; with divisor = 8 ; true\n\t\t\t\treturn Long.UONE;\n\t\t\t}\n\t\t\tres = Long.UZERO;\n\t\t}\n\n\t\t// Repeat the following until the remainder is less than other:  find a\n\t\t// floating-point that approximates remainder / other *from below*, add this\n\t\t// into the result, and subtract it from the remainder.  It is critical that\n\t\t// the approximate value is less than or equal to the real value so that the\n\t\t// remainder never becomes negative.\n\t\trem = this;\n\t\twhile (rem.greaterThanOrEqual(divisor)) {\n\t\t\t// Approximate the result of division. This may be a little greater or\n\t\t\t// smaller than the actual value.\n\t\t\tapprox = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n\n\t\t\t// We will tweak the approximate result by changing it in the 48-th digit or\n\t\t\t// the smallest non-fractional digit, whichever is larger.\n\t\t\tconst log2 = Math.ceil(Math.log(approx) / Math.LN2);\n\t\t\tconst delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n\t\t\t// Decrease the approximation until it is smaller than the remainder.  Note\n\t\t\t// that if it is too large, the product overflows and is negative.\n\t\t\tlet approxRes = Long.fromNumber(approx);\n\t\t\tlet approxRem = approxRes.multiply(divisor);\n\t\t\twhile (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n\t\t\t\tapprox -= delta;\n\t\t\t\tapproxRes = Long.fromNumber(approx, this.unsigned);\n\t\t\t\tapproxRem = approxRes.multiply(divisor);\n\t\t\t}\n\n\t\t\t// We know the answer can't be zero... and actually, zero would cause\n\t\t\t// infinite recursion since we would make no progress.\n\t\t\tif (approxRes.isZero()) {\n\t\t\t\tapproxRes = Long.ONE;\n\t\t\t}\n\n\t\t\tres = res.add(approxRes);\n\t\t\trem = rem.subtract(approxRem);\n\t\t}\n\t\treturn res;\n\t}\n\n\t// Returns this Long modulo the specified.\n\tmodulo(divisor: Long | number | string) {\n\t\tif (!(divisor instanceof Long)) {\n\t\t\tdivisor = Long.fromValue(divisor);\n\t\t}\n\n\t\treturn this.subtract(this.divide(divisor).multiply(divisor));\n\t}\n\n\t// Returns the bitwise NOT of this Long.\n\tnot() {\n\t\treturn Long.fromBits(~this.low, ~this.high, this.unsigned);\n\t}\n\n\t// Returns the bitwise AND of this Long and the specified.\n\tand(other: Long | number | string) {\n\t\tif (!(other instanceof Long)) {\n\t\t\tother = Long.fromValue(other);\n\t\t}\n\t\treturn Long.fromBits(\n\t\t\tthis.low & other.low,\n\t\t\tthis.high & other.high,\n\t\t\tthis.unsigned\n\t\t);\n\t}\n\n\t// Returns the bitwise OR of this Long and the specified.\n\tor(other: Long | number | string) {\n\t\tif (!(other instanceof Long)) {\n\t\t\tother = Long.fromValue(other);\n\t\t}\n\t\treturn Long.fromBits(\n\t\t\tthis.low | other.low,\n\t\t\tthis.high | other.high,\n\t\t\tthis.unsigned\n\t\t);\n\t}\n\n\t// Returns the bitwise XOR of this Long and the given one.\n\txor(other: Long | number | string) {\n\t\tif (!(other instanceof Long)) {\n\t\t\tother = Long.fromValue(other);\n\t\t}\n\t\treturn Long.fromBits(\n\t\t\tthis.low ^ other.low,\n\t\t\tthis.high ^ other.high,\n\t\t\tthis.unsigned\n\t\t);\n\t}\n\n\t// Returns this Long with bits shifted to the left by the given amount.\n\tshiftLeft(numBits: number | Long) {\n\t\tif (numBits instanceof Long) {\n\t\t\tnumBits = numBits.toInt();\n\t\t}\n\t\tif ((numBits &= 63) === 0) {\n\t\t\treturn this;\n\t\t} else if (numBits < 32) {\n\t\t\treturn Long.fromBits(\n\t\t\t\tthis.low << numBits,\n\t\t\t\t(this.high << numBits) | (this.low >>> (32 - numBits)),\n\t\t\t\tthis.unsigned\n\t\t\t);\n\t\t} else {\n\t\t\treturn Long.fromBits(0, this.low << (numBits - 32), this.unsigned);\n\t\t}\n\t}\n\n\t// Returns this Long with bits arithmetically shifted to the right by the given amount.\n\tshiftRight(numBits: number | Long) {\n\t\tif (numBits instanceof Long) {\n\t\t\tnumBits = numBits.toInt();\n\t\t}\n\t\tif ((numBits &= 63) === 0) {\n\t\t\treturn this;\n\t\t} else if (numBits < 32) {\n\t\t\treturn Long.fromBits(\n\t\t\t\t(this.low >>> numBits) | (this.high << (32 - numBits)),\n\t\t\t\tthis.high >> numBits,\n\t\t\t\tthis.unsigned\n\t\t\t);\n\t\t} else {\n\t\t\treturn Long.fromBits(\n\t\t\t\tthis.high >> (numBits - 32),\n\t\t\t\tthis.high >= 0 ? 0 : -1,\n\t\t\t\tthis.unsigned\n\t\t\t);\n\t\t}\n\t}\n\n\t// Returns this Long with bits logically shifted to the right by the given amount.\n\tshiftRightUnsigned(numBits: number | Long) {\n\t\tif (numBits instanceof Long) {\n\t\t\tnumBits = numBits.toInt();\n\t\t}\n\t\tif ((numBits &= 63) === 0) {\n\t\t\treturn this;\n\t\t}\n\t\tif (numBits < 32) {\n\t\t\treturn Long.fromBits(\n\t\t\t\t(this.low >>> numBits) | (this.high << (32 - numBits)),\n\t\t\t\tthis.high >>> numBits,\n\t\t\t\tthis.unsigned\n\t\t\t);\n\t\t}\n\t\tif (numBits === 32) {\n\t\t\treturn Long.fromBits(this.high, 0, this.unsigned);\n\t\t}\n\t\treturn Long.fromBits(this.high >>> (numBits - 32), 0, this.unsigned);\n\t}\n\n\t// Returns this Long with bits rotated to the left by the given amount.\n\trotateLeft(numBits: number | Long) {\n\t\tlet b;\n\t\tif (numBits instanceof Long) {\n\t\t\tnumBits = numBits.toInt();\n\t\t}\n\t\tif ((numBits &= 63) === 0) {\n\t\t\treturn this;\n\t\t}\n\t\tif (numBits === 32) {\n\t\t\treturn Long.fromBits(this.high, this.low, this.unsigned);\n\t\t}\n\t\tif (numBits < 32) {\n\t\t\tb = 32 - numBits;\n\t\t\treturn Long.fromBits(\n\t\t\t\t(this.low << numBits) | (this.high >>> b),\n\t\t\t\t(this.high << numBits) | (this.low >>> b),\n\t\t\t\tthis.unsigned\n\t\t\t);\n\t\t}\n\t\tnumBits -= 32;\n\t\tb = 32 - numBits;\n\t\treturn Long.fromBits(\n\t\t\t(this.high << numBits) | (this.low >>> b),\n\t\t\t(this.low << numBits) | (this.high >>> b),\n\t\t\tthis.unsigned\n\t\t);\n\t}\n\n\t// Returns this Long with bits rotated to the right by the given amount.\n\trotateRight(numBits: number | Long) {\n\t\tlet b;\n\t\tif (numBits instanceof Long) {\n\t\t\tnumBits = numBits.toInt();\n\t\t}\n\t\tif ((numBits &= 63) === 0) {\n\t\t\treturn this;\n\t\t}\n\t\tif (numBits === 32) {\n\t\t\treturn Long.fromBits(this.high, this.low, this.unsigned);\n\t\t}\n\t\tif (numBits < 32) {\n\t\t\tb = 32 - numBits;\n\t\t\treturn Long.fromBits(\n\t\t\t\t(this.high << b) | (this.low >>> numBits),\n\t\t\t\t(this.low << b) | (this.high >>> numBits),\n\t\t\t\tthis.unsigned\n\t\t\t);\n\t\t}\n\t\tnumBits -= 32;\n\t\tb = 32 - numBits;\n\t\treturn Long.fromBits(\n\t\t\t(this.low << b) | (this.high >>> numBits),\n\t\t\t(this.high << b) | (this.low >>> numBits),\n\t\t\tthis.unsigned\n\t\t);\n\t}\n\n\t// Converts this Long to signed.\n\ttoSigned() {\n\t\tif (!this.unsigned) {\n\t\t\treturn this;\n\t\t}\n\t\treturn Long.fromBits(this.low, this.high, false);\n\t}\n\n\t//Converts this Long to unsigned.\n\ttoUnsigned() {\n\t\tif (this.unsigned) {\n\t\t\treturn this;\n\t\t}\n\t\treturn Long.fromBits(this.low, this.high, true);\n\t}\n\n\t// Converts this Long to its byte representation.\n\ttoBytes(le?: boolean) {\n\t\treturn le ? this.toBytesLE() : this.toBytesBE();\n\t}\n\n\t//Converts this Long to its little endian byte representation.\n\ttoBytesLE() {\n\t\tconst hi = this.high;\n\t\tconst lo = this.low;\n\t\treturn [\n\t\t\tlo & 0xff,\n\t\t\t(lo >>> 8) & 0xff,\n\t\t\t(lo >>> 16) & 0xff,\n\t\t\tlo >>> 24,\n\t\t\thi & 0xff,\n\t\t\t(hi >>> 8) & 0xff,\n\t\t\t(hi >>> 16) & 0xff,\n\t\t\thi >>> 24,\n\t\t];\n\t}\n\n\t// Converts this Long to its big endian byte representation.\n\ttoBytesBE() {\n\t\tconst hi = this.high;\n\t\tconst lo = this.low;\n\t\treturn [\n\t\t\thi >>> 24,\n\t\t\t(hi >>> 16) & 0xff,\n\t\t\t(hi >>> 8) & 0xff,\n\t\t\thi & 0xff,\n\t\t\tlo >>> 24,\n\t\t\t(lo >>> 16) & 0xff,\n\t\t\t(lo >>> 8) & 0xff,\n\t\t\tlo & 0xff,\n\t\t];\n\t}\n\n\t// Creates a Long from its byte representation.\n\tstatic fromBytes(bytes: number[], unsigned?: boolean, le?: boolean) {\n\t\treturn le\n\t\t\t? Long.fromBytesLE(bytes, unsigned)\n\t\t\t: Long.fromBytesBE(bytes, unsigned);\n\t}\n\n\t// Creates a Long from its little endian byte representation.\n\tstatic fromBytesLE(bytes: number[], unsigned?: boolean) {\n\t\treturn new Long(\n\t\t\tbytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24),\n\t\t\tbytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24),\n\t\t\tunsigned\n\t\t);\n\t}\n\n\t// Creates a Long from its big endian byte representation.\n\tstatic fromBytesBE(bytes: number[], unsigned?: boolean) {\n\t\treturn new Long(\n\t\t\t(bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7],\n\t\t\t(bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3],\n\t\t\tunsigned\n\t\t);\n\t}\n\n\tstatic fromInt(value: number, unsigned?: boolean) {\n\t\tlet cache;\n\t\tif (unsigned) {\n\t\t\tvalue >>>= 0;\n\t\t\tif ((cache = 0 <= value && value < 256)) {\n\t\t\t\tconst cachedObj = UINT_CACHE[value];\n\t\t\t\tif (cachedObj) {\n\t\t\t\t\treturn cachedObj;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n\t\t\tif (cache) {\n\t\t\t\tUINT_CACHE[value] = obj;\n\t\t\t}\n\t\t\treturn obj;\n\t\t} else {\n\t\t\tvalue |= 0;\n\t\t\tif ((cache = -128 <= value && value < 128)) {\n\t\t\t\tconst cachedObj = INT_CACHE[value];\n\t\t\t\tif (cachedObj) {\n\t\t\t\t\treturn cachedObj;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst obj = Long.fromBits(value, value < 0 ? -1 : 0, false);\n\t\t\tif (cache) {\n\t\t\t\tINT_CACHE[value] = obj;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t}\n\n\tstatic fromNumber(value: number, unsigned?: boolean): Long {\n\t\tif (isNaN(value)) {\n\t\t\treturn unsigned ? Long.UZERO : Long.ZERO;\n\t\t}\n\t\tif (unsigned) {\n\t\t\tif (value < 0) {\n\t\t\t\treturn Long.UZERO;\n\t\t\t}\n\t\t\tif (value >= TWO_PWR_64_DBL) {\n\t\t\t\treturn Long.MAX_UNSIGNED_VALUE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (value <= -TWO_PWR_63_DBL) {\n\t\t\t\treturn Long.MIN_VALUE;\n\t\t\t}\n\t\t\tif (value + 1 >= TWO_PWR_63_DBL) {\n\t\t\t\treturn Long.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tif (value < 0) {\n\t\t\treturn Long.fromNumber(-value, unsigned).negate();\n\t\t}\n\t\treturn Long.fromBits(\n\t\t\tvalue % TWO_PWR_32_DBL | 0,\n\t\t\t(value / TWO_PWR_32_DBL) | 0,\n\t\t\tunsigned\n\t\t);\n\t}\n\n\tstatic fromBits(lowBits: number, highBits: number, unsigned?: boolean) {\n\t\treturn new Long(lowBits, highBits, unsigned);\n\t}\n\n\tstatic fromString(\n\t\tstr: string,\n\t\tunsigned?: boolean | number,\n\t\tradix?: number\n\t): Long {\n\t\tif (str.length === 0) {\n\t\t\tthrow Error(\"empty string\");\n\t\t}\n\t\tif (\n\t\t\tstr === \"NaN\" ||\n\t\t\tstr === \"Infinity\" ||\n\t\t\tstr === \"+Infinity\" ||\n\t\t\tstr === \"-Infinity\"\n\t\t) {\n\t\t\treturn Long.ZERO;\n\t\t}\n\t\tif (typeof unsigned === \"number\") {\n\t\t\t// For goog.math.long compatibility\n\t\t\t(radix = unsigned), (unsigned = false);\n\t\t} else {\n\t\t\tunsigned = !!unsigned;\n\t\t}\n\t\tradix = radix || 10;\n\t\tif (radix < 2 || 36 < radix) {\n\t\t\tthrow RangeError(\"radix\");\n\t\t}\n\n\t\tlet p;\n\t\tif ((p = str.indexOf(\"-\")) > 0) {\n\t\t\tthrow Error(\"interior hyphen\");\n\t\t} else if (p === 0) {\n\t\t\treturn Long.fromString(str.substring(1), unsigned, radix).negate();\n\t\t}\n\n\t\t// Do several (8) digits each time through the loop, so as to\n\t\t// minimize the calls to the very expensive emulated div.\n\t\tconst radixToPower = Long.fromNumber(Math.pow(radix, 8));\n\n\t\tlet result = Long.ZERO;\n\t\tfor (let i = 0; i < str.length; i += 8) {\n\t\t\tconst size = Math.min(8, str.length - i);\n\t\t\tconst value = parseInt(str.substring(i, i + size), radix);\n\t\t\tif (size < 8) {\n\t\t\t\tconst power = Long.fromNumber(Math.pow(radix, size));\n\t\t\t\tresult = result.multiply(power).add(Long.fromNumber(value));\n\t\t\t} else {\n\t\t\t\tresult = result.multiply(radixToPower);\n\t\t\t\tresult = result.add(Long.fromNumber(value));\n\t\t\t}\n\t\t}\n\t\tresult.unsigned = unsigned;\n\t\treturn result;\n\t}\n\n\tstatic fromValue(\n\t\tval:\n\t\t\t| Long\n\t\t\t| number\n\t\t\t| string\n\t\t\t| { low: number; high: number; unsigned: boolean },\n\t\tunsigned?: boolean\n\t) {\n\t\tif (typeof val === \"number\") {\n\t\t\treturn Long.fromNumber(val, unsigned);\n\t\t}\n\t\tif (typeof val === \"string\") {\n\t\t\treturn Long.fromString(val, unsigned);\n\t\t}\n\t\treturn Long.fromBits(\n\t\t\tval.low,\n\t\t\tval.high,\n\t\t\ttypeof unsigned === \"boolean\" ? unsigned : val.unsigned\n\t\t);\n\t}\n}\n\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_24_DBL = 1 << 24;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\nconst TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);\n"],"names":["INT_CACHE","UINT_CACHE","Long","low","high","unsigned","this","toInt","toNumber","TWO_PWR_32_DBL","toString","radix","RangeError","isZero","isNegative","equals","MIN_VALUE","radixLong","fromNumber","div","divide","rem1","multiply","subtract","negate","radixToPower","Math","pow","result","rem","remDiv","digits","length","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","bit","val","isPositive","isOdd","isEven","other","fromValue","notEquals","lessThan","compare","lessThanOrEqual","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","not","add","ONE","addend","c48","c32","c16","c00","fromBits","subtrahend","multiplier","ZERO","TWO_PWR_24","a32","a16","a00","b32","b16","b00","divisor","Error","UZERO","approx","res","toUnsigned","shiftRightUnsigned","UONE","NEG_ONE","shiftRight","shiftLeft","max","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","modulo","and","or","xor","numBits","rotateLeft","b","rotateRight","toSigned","toBytes","le","toBytesLE","toBytesBE","hi","lo","fromBytes","bytes","fromBytesLE","fromBytesBE","fromInt","value","cache","cachedObj","obj","isNaN","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","MAX_VALUE","lowBits","highBits","fromString","str","p","indexOf","substring","i","size","min","parseInt","power","TWO_PWR_16_DBL"],"mappings":"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"}